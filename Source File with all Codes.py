# -*- coding: utf-8 -*-
"""Assignment-02-PDC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BsMkdhzFjUvAfFyf0PmYPrAzU7xwA60E

**Muhammad Ali Tahir**<br>
**CMS: 411327**<br>
**BSCS-12C**

# ***Practical Implementation of Causal Ordering Algorithms***

##########################################
##########################################

##**BSS-based causal ordering**
"""

##########################################
##########################################

pip install matplotlib networkx

import numpy as np
import matplotlib.pyplot as plt
from collections import defaultdict, deque
from typing import Dict, List, Tuple, Any, Optional

class Process:
    def __init__(self, process_id: int, num_processes: int):
        self.id = process_id
        self.num_processes = num_processes

        # Vector clock: tracks logical time for each process
        self.vector_clock = [0] * num_processes

        # Event history for visualization
        self.events = []
        self.event_clocks = []

        # Delayed messages waiting for their causal dependencies
        self.delayed_messages = []

    def send_message(self, target_id: int, content: Any) -> Tuple[int, Any, List[int]]:
        """
        Prepares a message to be sent with vector clock timestamp.
        """
        # Increment our position in the vector clock before sending
        self.vector_clock[self.id] += 1

        # Record this event
        self.events.append(f"Send to P{target_id}: {content}")
        self.event_clocks.append(self.vector_clock.copy())

        # Return message with a copy of our current vector clock
        return (target_id, content, self.vector_clock.copy())

    def receive_message(self, sender_id: int, content: Any, sender_vector: List[int]) -> bool:
        """
        Receives a message and processes it if all causal dependencies are met.
        """
        # Check if this message is causally ready to be delivered
        if self._is_deliverable(sender_vector):
            # Update our vector clock
            self._update_vector_clock(sender_vector)

            # Record this event
            self.events.append(f"Receive from P{sender_id}: {content}")
            self.event_clocks.append(self.vector_clock.copy())

            # Check if any pending messages can now be delivered
            self._check_delayed_messages()

            return True
        else:
            # Store the message for later delivery
            self.delayed_messages.append((sender_id, content, sender_vector))

            # Record this event
            self.events.append(f"Delay from P{sender_id}: {content}")
            self.event_clocks.append(self.vector_clock.copy())

            return False

    def _is_deliverable(self, sender_vector: List[int]) -> bool:
        """
        Checks if a message with the given vector clock can be delivered.
        """
        # Identify the sender (the process with the highest counter)
        sender_id = -1
        for i in range(self.num_processes):
            if sender_vector[i] > self.vector_clock[i]:
                if sender_id == -1:
                    sender_id = i
                else:
                    # More than one process ahead - not deliverable yet
                    return False

        if sender_id == -1:
            # Message is already delivered or is a duplicate
            return False

        # Check if the sender's counter is exactly one more than our record
        if sender_vector[sender_id] != self.vector_clock[sender_id] + 1:
            return False

        # Check that all other vector positions are less than or equal to our values
        for i in range(self.num_processes):
            if i != sender_id and sender_vector[i] > self.vector_clock[i]:
                return False

        return True

    def _update_vector_clock(self, sender_vector: List[int]) -> None:
        """
        Updates our vector clock based on received message.
        """
        for i in range(self.num_processes):
            self.vector_clock[i] = max(self.vector_clock[i], sender_vector[i])

    def _check_delayed_messages(self) -> None:
        """
        Checks if any delayed messages can now be delivered.
        """
        delivered_something = True
        while delivered_something:
            delivered_something = False

            for i in range(len(self.delayed_messages)):
                if i >= len(self.delayed_messages):
                    break

                sender_id, content, sender_vector = self.delayed_messages[i]

                if self._is_deliverable(sender_vector):
                    # Remove from delayed messages
                    del self.delayed_messages[i]

                    # Update our vector clock
                    self._update_vector_clock(sender_vector)

                    # Record this event
                    self.events.append(f"Deliver delayed from P{sender_id}: {content}")
                    self.event_clocks.append(self.vector_clock.copy())

                    # We've delivered something, so check again
                    delivered_something = True
                    break


class CausalOrderingSystem:
    def __init__(self, num_processes: int):
        self.processes = [Process(i, num_processes) for i in range(num_processes)]
        self.system_events = []
        self.colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']

    def send_message(self, sender_id: int, receiver_id: int, content: Any, delay: bool = False) -> None:
        """
        Sends a message from one process to another, respecting causal ordering.
        """
        sender = self.processes[sender_id]
        message = sender.send_message(receiver_id, content)

        event = f"P{sender_id} -> P{receiver_id}: {content}"
        self.system_events.append(event)

        if not delay:
            self._deliver_message(message)
        else:
            # For simulation, we'll add a delayed message
            self.system_events.append(f"(Delayed) {event}")
            return message

    def _deliver_message(self, message: Tuple[int, Any, List[int]]) -> bool:
        """
        Delivers a message to a process.
        """
        receiver_id, content, sender_vector = message

        # Find the sender ID from the vector clock
        sender_id = -1
        for i, val in enumerate(sender_vector):
            if val > 0:
                sender_id = i
                break

        receiver = self.processes[receiver_id]
        result = receiver.receive_message(sender_id, content, sender_vector)

        if result:
            self.system_events.append(f"P{receiver_id} received: {content}")
        else:
            self.system_events.append(f"P{receiver_id} delayed: {content}")

        return result

    def plot_process_timelines(self):
        """
        Visualizes the causal ordering of events across processes.
        """
        fig, ax = plt.subplots(figsize=(12, 8))

        # Plot each process timeline
        for p_id, process in enumerate(self.processes):
            y_position = p_id * 2

            # Plot timeline
            ax.plot([0, len(self.system_events)], [y_position, y_position],
                    color=self.colors[p_id % len(self.colors)],
                    linestyle='-', linewidth=1)

            # Plot events
            for i, (event, clock) in enumerate(zip(process.events, process.event_clocks)):
                x_position = i * 0.5

                # Plot event point
                ax.plot(x_position, y_position, 'o',
                        color=self.colors[p_id % len(self.colors)],
                        markersize=8)

                # Add event label
                event_label = event.split(': ')[0]
                ax.text(x_position, y_position + 0.2, event_label,
                        ha='center', va='bottom', fontsize=8, rotation=45)

                # Add vector clock label
                clock_label = f"[{','.join(map(str, clock))}]"
                ax.text(x_position, y_position - 0.3, clock_label,
                        ha='center', va='top', fontsize=8)

        # Customize plot
        ax.set_yticks([p_id * 2 for p_id in range(len(self.processes))])
        ax.set_yticklabels([f"Process {p_id}" for p_id in range(len(self.processes))])
        ax.set_xlabel('Event Sequence')
        ax.set_title('BSS Causal Ordering Process Timeline')
        ax.grid(True, linestyle='--', alpha=0.7)

        # Adjust layout
        plt.tight_layout()
        plt.show()

        return fig

    def run_simulation(self, scenario='basic'):
        """
        Runs a simulation of the system with different scenarios.
        """
        if scenario == 'basic':
            # Simple causal chain
            print("Running basic causal chain scenario...")
            self.send_message(0, 1, "Message A")
            self.send_message(1, 2, "Message B")
            self.send_message(2, 0, "Message C")

        elif scenario == 'out_of_order':
            # Out of order delivery
            print("Running out-of-order delivery scenario...")
            self.send_message(0, 1, "Message A")
            self.send_message(1, 2, "Message B")
            # Simulate message C being delayed
            delayed_msg = self.send_message(0, 2, "Message C", delay=True)
            # Deliver Message D first (out of causal order)
            self.send_message(0, 2, "Message D")
            # Now deliver delayed Message C
            self._deliver_message(delayed_msg)

        elif scenario == 'causal_violation':
            # Causal violation demonstration
            print("Running causal violation demonstration...")
            self.send_message(0, 1, "Message A")
            # Process 1 sends message to process 2, which depends on message A
            msg_b = self.send_message(1, 2, "Message B", delay=True)
            # Process 0 sends message directly to process 2
            self.send_message(0, 2, "Message C")
            # Now deliver Message B (should be delayed due to causal dependency)
            self._deliver_message(msg_b)

        else:
            print(f"Unknown scenario: {scenario}")

        # Print event log
        print("\nEvent Log:")
        for i, event in enumerate(self.system_events):
            print(f"{i}: {event}")

        # Return the final state of vector clocks
        print("\nFinal Vector Clocks:")
        for i, process in enumerate(self.processes):
            print(f"Process {i}: {process.vector_clock}")

# Example usage (run this in a notebook cell)
# Create a system with 3 processes
system = CausalOrderingSystem(3)

# Run the out-of-order scenario
system.run_simulation('out_of_order')

# Plot the timeline
system.plot_process_timelines()

##########################################
##########################################
##########################################

"""##**SEC-Casual Ordering**"""

import matplotlib.pyplot as plt

class ProcessSES:
    def __init__(self, process_id: int, num_processes: int):
        self.id = process_id
        self.num_processes = num_processes
        self.sequence_number = 0
        self.received_sequence = [0] * num_processes  # Last received sequence from each process
        self.events = []
        self.delayed_messages = []

    def send_message(self, target_id: int, content: str) -> tuple:
        self.sequence_number += 1
        self.events.append(f"Send to P{target_id}: {content}")
        return (target_id, content, self.sequence_number, self.id)

    def receive_message(self, sender_id: int, content: str, sequence_number: int, original_sender: int) -> bool:
        if sequence_number == self.received_sequence[original_sender] + 1:
            self.received_sequence[original_sender] = sequence_number
            self.events.append(f"Receive from P{original_sender}: {content}")
            self._check_delayed_messages()
            return True
        else:
            self.delayed_messages.append((original_sender, content, sequence_number, original_sender))
            self.events.append(f"Delay from P{original_sender}: {content}")
            return False

    def _check_delayed_messages(self):
        delivered = True
        while delivered:
            delivered = False
            for i in range(len(self.delayed_messages)):
                sender_id, content, sequence_number, original_sender = self.delayed_messages[i]
                if sequence_number == self.received_sequence[original_sender] + 1:
                    del self.delayed_messages[i]
                    self.received_sequence[original_sender] = sequence_number
                    self.events.append(f"Deliver delayed from P{original_sender}: {content}")
                    delivered = True
                    break

class CausalOrderingSystemSES:
    def __init__(self, num_processes: int):
        self.processes = [ProcessSES(i, num_processes) for i in range(num_processes)]
        self.system_events = []
        self.colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']

    def send_message(self, sender_id: int, receiver_id: int, content: str, delay: bool = False) -> tuple:
        sender = self.processes[sender_id]
        message = sender.send_message(receiver_id, content)
        event = f"P{sender_id} -> P{receiver_id}: {content}"
        self.system_events.append(event)
        if not delay:
            self._deliver_message(message)
        else:
            self.system_events.append(f"(Delayed) {event}")
            return message

    def _deliver_message(self, message: tuple) -> bool:
        receiver_id, content, sequence_number, original_sender = message
        receiver = self.processes[receiver_id]
        result = receiver.receive_message(original_sender, content, sequence_number, original_sender)
        if result:
            self.system_events.append(f"P{receiver_id} received: {content}")
        else:
            self.system_events.append(f"P{receiver_id} delayed: {content}")
        return result

    def plot_process_timelines(self):
        fig, ax = plt.subplots(figsize=(12, 8))
        for p_id, process in enumerate(self.processes):
            y_position = p_id * 2
            ax.plot([0, len(self.system_events)], [y_position, y_position],
                    color=self.colors[p_id % len(self.colors)], linestyle='-', linewidth=1)
            for i, event in enumerate(process.events):
                x_position = i * 0.5
                ax.plot(x_position, y_position, 'o', color=self.colors[p_id % len(self.colors)], markersize=8)
                event_label = event.split(': ')[0]
                ax.text(x_position, y_position + 0.2, event_label, ha='center', va='bottom', fontsize=8, rotation=45)
        ax.set_yticks([p_id * 2 for p_id in range(len(self.processes))])
        ax.set_yticklabels([f"Process {p_id}" for p_id in range(len(self.processes))])
        ax.set_xlabel('Event Sequence')
        ax.set_title('SES Causal Ordering Process Timeline')
        ax.grid(True, linestyle='--', alpha=0.7)
        plt.tight_layout()
        plt.show()

    def run_simulation(self, scenario='basic'):
        if scenario == 'basic':
            self.send_message(0, 1, "Message A")
            self.send_message(1, 2, "Message B")
            self.send_message(2, 0, "Message C")
        elif scenario == 'out_of_order':
            self.send_message(0, 1, "Message A")
            self.send_message(1, 2, "Message B")
            delayed_msg = self.send_message(0, 2, "Message C", delay=True)
            self.send_message(0, 2, "Message D")
            self._deliver_message(delayed_msg)
        elif scenario == 'potential_violation':
            self.send_message(0, 1, "Message A")
            msg_b = self.send_message(1, 2, "Message B", delay=True)
            self.send_message(0, 2, "Message C")
            self._deliver_message(msg_b)
        else:
            print(f"Unknown scenario: {scenario}")
        print("\nEvent Log:")
        for i, event in enumerate(self.system_events):
            print(f"{i}: {event}")
        for i, process in enumerate(self.processes):
            print(f"\nProcess {i} received sequence: {process.received_sequence}")

# Example usage
system_ses = CausalOrderingSystemSES(3)
system_ses.run_simulation('out_of_order')
system_ses.plot_process_timelines()

##########################################
##########################################
##########################################

"""##**Matrix Clock - Casual Ordering**"""

##########################################
##########################################

import numpy as np
import matplotlib.pyplot as plt

class ProcessMatrix:
    def __init__(self, process_id: int, num_processes: int):
        self.id = process_id
        self.num_processes = num_processes
        self.matrix_clock = np.zeros((num_processes, num_processes), dtype=int)
        self.events = []
        self.delayed_messages = []

    def send_message(self, target_id: int, content: str) -> tuple:
        self.matrix_clock[self.id, self.id] += 1
        self.events.append(f"Send to P{target_id}: {content}")
        return (target_id, content, self.matrix_clock.copy())

    def receive_message(self, sender_id: int, content: str, sender_matrix: np.ndarray) -> bool:
        if self._is_deliverable(sender_matrix):
            self._update_matrix_clock(sender_matrix)
            self.events.append(f"Receive from P{sender_id}: {content}")
            self._check_delayed_messages()
            return True
        else:
            self.delayed_messages.append((sender_id, content, sender_matrix))
            self.events.append(f"Delay from P{sender_id}: {content}")
            return False

    def _is_deliverable(self, sender_matrix: np.ndarray) -> bool:
        # check that the senders row is one more than the receivers row in the senders column.
        if sender_matrix[self.id, self.id] != self.matrix_clock[self.id, self.id] + 1:
            return False
        # Check that the sender matrix is less than or equal to the receiver matrix.
        if not np.all(sender_matrix <= self.matrix_clock):
            return False
        return True

    def _update_matrix_clock(self, sender_matrix: np.ndarray):
        self.matrix_clock = np.maximum(self.matrix_clock, sender_matrix)
        self.matrix_clock[self.id] = self.matrix_clock[self.id, :]

    def _check_delayed_messages(self):
        delivered = True
        while delivered:
            delivered = False
            for i in range(len(self.delayed_messages)):
                sender_id, content, sender_matrix = self.delayed_messages[i]
                if self._is_deliverable(sender_matrix):
                    del self.delayed_messages[i]
                    self._update_matrix_clock(sender_matrix)
                    self.events.append(f"Deliver delayed from P{sender_id}: {content}")
                    delivered = True
                    break

class CausalOrderingSystemMatrix:
    def __init__(self, num_processes: int):
        self.processes = [ProcessMatrix(i, num_processes) for i in range(num_processes)]
        self.system_events = []
        self.colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']

    def send_message(self, sender_id: int, receiver_id: int, content: str, delay: bool = False) -> tuple:
        sender = self.processes[sender_id]
        message = sender.send_message(receiver_id, content)
        event = f"P{sender_id} -> P{receiver_id}: {content}"
        self.system_events.append(event)
        if not delay:
            self._deliver_message(message)
        else:
            self.system_events.append(f"(Delayed) {event}")
            return message

    def _deliver_message(self, message: tuple) -> bool:
        receiver_id, content, sender_matrix = message
        receiver = self.processes[receiver_id]
        result = receiver.receive_message(message[3] if len(message) > 3 else message[0], content, sender_matrix)
        if result:
            self.system_events.append(f"P{receiver_id} received: {content}")
        else:
            self.system_events.append(f"P{receiver_id} delayed: {content}")
        return result

    def plot_process_timelines(self):
        fig, ax = plt.subplots(figsize=(12, 8))
        for p_id, process in enumerate(self.processes):
            y_position = p_id * 2
            ax.plot([0, len(self.system_events)], [y_position, y_position],
                    color=self.colors[p_id % len(self.colors)], linestyle='-', linewidth=1)
            for i, event in enumerate(process.events):
                x_position = i * 0.5
                ax.plot(x_position, y_position, 'o', color=self.colors[p_id % len(self.colors)], markersize=8)
                event_label = event.split(': ')[0]
                ax.text(x_position, y_position + 0.2, event_label, ha='center', va='bottom', fontsize=8, rotation=45)
        ax.set_yticks([p_id * 2 for p_id in range(len(self.processes))])
        ax.set_yticklabels([f"Process {p_id}" for p_id in range(len(self.processes))])
        ax.set_xlabel('Event Sequence')
        ax.set_title('Matrix Clock Causal Ordering Process Timeline')
        ax.grid(True, linestyle='--', alpha=0.7)
        plt.tight_layout()
        plt.show()

    def run_simulation(self, scenario='basic'):
        if scenario == 'basic':
            self.send_message(0, 1, "Message A")
            self.send_message(1, 2, "Message B")
            self.send_message(2, 0, "Message C")
        elif scenario == 'out_of_order':
            self.send_message(0, 1, "Message A")
            self.send_message(1, 2, "Message B")
            delayed_msg = self.send_message(0, 2, "Message C", delay=True)
            self.send_message(0, 2, "Message D")
            self._deliver_message(delayed_msg)
        elif scenario == 'causal_violation':
            self.send_message(0, 1, "Message A")
            msg_b = self.send_message(1, 2, "Message B", delay=True)
            self.send_message(0, 2, "Message C")
            self._deliver_message(msg_b)
        else:
            print(f"Unknown scenario: {scenario}")
        print("\nEvent Log:")
        for i, event in enumerate(self.system_events):
            print(f"{i}: {event}")
        for i, process in enumerate(self.processes):
            print(f"\nProcess {i} Matrix Clock: \n{process.matrix_clock}")

# Example usage
system_matrix = CausalOrderingSystemMatrix(3)
system_matrix.run_simulation('out_of_order')
system_matrix.plot_process_timelines()

##########################################
##########################################
##########################################


"""# ***Simulation of real-world distributed application***

# **Problem:<br>**
In real-world collaborative editing scenarios (like Google Docs), multiple users can edit the same document simultaneously.<br>

This concurrency can lead to conflicts if changes are not applied in a consistent order across all users' views.<br>

Without proper synchronization, users might see different versions of the document, leading to confusion and data loss.<br>
"""

import numpy as np
import matplotlib.pyplot as plt

class CollaborativeEditProcess:
    def __init__(self, process_id: int, num_processes: int, document: str = ""):
        self.id = process_id
        self.num_processes = num_processes
        self.document = document
        self.matrix_clock = np.zeros((num_processes, num_processes), dtype=int)
        self.events = []
        self.delayed_operations = []

    def perform_operation(self, operation: str, position: int, content: str) -> tuple:
        self.matrix_clock[self.id, self.id] += 1
        self.document = self._apply_operation(operation, position, content)
        self.events.append(f"Operation: {operation} at {position} '{content}'")
        return (self.id, operation, position, content, self.matrix_clock.copy())

    def receive_operation(self, sender_id: int, operation: str, position: int, content: str, sender_matrix: np.ndarray) -> bool:
        if self._is_deliverable(sender_matrix):
            self._update_matrix_clock(sender_matrix)
            self.document = self._apply_operation(operation, position, content)
            self.events.append(f"Received Operation: {operation} at {position} '{content}' from P{sender_id}")
            self._check_delayed_operations()
            return True
        else:
            self.delayed_operations.append((sender_id, operation, position, content, sender_matrix))
            self.events.append(f"Delayed Operation: {operation} at {position} '{content}' from P{sender_id}")
            return False

    def _apply_operation(self, operation: str, position: int, content: str) -> str:
        if operation == "INSERT":
            return self.document[:position] + content + self.document[position:]
        elif operation == "DELETE":
            return self.document[:position] + self.document[position + len(content):]
        else:
            return self.document

    def _is_deliverable(self, sender_matrix: np.ndarray) -> bool:
        if sender_matrix[self.id, self.id] != self.matrix_clock[self.id, self.id] + 1:
            return False
        if not np.all(sender_matrix <= self.matrix_clock):
            return False
        return True

    def _update_matrix_clock(self, sender_matrix: np.ndarray):
        self.matrix_clock = np.maximum(self.matrix_clock, sender_matrix)
        self.matrix_clock[self.id] = self.matrix_clock[self.id, :]

    def _check_delayed_operations(self):
        delivered = True
        while delivered:
            delivered = False
            for i in range(len(self.delayed_operations)):
                sender_id, operation, position, content, sender_matrix = self.delayed_operations[i]
                if self._is_deliverable(sender_matrix):
                    del self.delayed_operations[i]
                    self._update_matrix_clock(sender_matrix)
                    self.document = self._apply_operation(operation, position, content)
                    self.events.append(f"Deliver delayed Operation: {operation} at {position} '{content}' from P{sender_id}")
                    delivered = True
                    break

class CollaborativeEditorSystem:
    def __init__(self, num_processes: int, initial_document: str = ""):
        self.processes = [CollaborativeEditProcess(i, num_processes, initial_document) for i in range(num_processes)]
        self.system_events = []
        self.colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']

    def perform_and_send_operation(self, sender_id: int, operation: str, position: int, content: str, delay: bool = False) -> tuple:
        sender = self.processes[sender_id]
        operation_data = sender.perform_operation(operation, position, content)
        receiver_ids = [i for i in range(len(self.processes)) if i != sender_id]
        for receiver_id in receiver_ids:
            event = f"P{sender_id} -> P{receiver_id}: {operation} at {position} '{content}'"
            self.system_events.append(event)
            if not delay:
                self._deliver_operation(receiver_id, operation_data)
            else:
                self.system_events.append(f"(Delayed) {event}")
                return operation_data

    def _deliver_operation(self, receiver_id: int, operation_data: tuple) -> bool:
        sender_id, operation, position, content, sender_matrix = operation_data
        receiver = self.processes[receiver_id]
        result = receiver.receive_operation(sender_id, operation, position, content, sender_matrix)
        if result:
            self.system_events.append(f"P{receiver_id} received operation: {operation} at {position} '{content}'")
        else:
            self.system_events.append(f"P{receiver_id} delayed operation: {operation} at {position} '{content}'")
        return result

    def plot_process_timelines(self):
        fig, ax = plt.subplots(figsize=(12, 8))
        for p_id, process in enumerate(self.processes):
            y_position = p_id * 2
            ax.plot([0, len(self.system_events)], [y_position, y_position],
                    color=self.colors[p_id % len(self.colors)], linestyle='-', linewidth=1)
            for i, event in enumerate(process.events):
                x_position = i * 0.5
                ax.plot(x_position, y_position, 'o', color=self.colors[p_id % len(self.colors)], markersize=8)
                event_label = event.split(': ')[0]
                ax.text(x_position, y_position + 0.2, event_label, ha='center', va='bottom', fontsize=8, rotation=45)
        ax.set_yticks([p_id * 2 for p_id in range(len(self.processes))])
        ax.set_yticklabels([f"Process {p_id}" for p_id in range(len(self.processes))])
        ax.set_xlabel('Event Sequence')
        ax.set_title('Collaborative Document Editor Timeline')
        ax.grid(True, linestyle='--', alpha=0.7)
        plt.tight_layout()
        plt.show()

    def run_simulation(self):
        self.perform_and_send_operation(0, "INSERT", 0, "Hello")
        self.perform_and_send_operation(1, "INSERT", 5, ", world")
        delayed_op = self.perform_and_send_operation(0, "DELETE", 5, "o", delay=True)
        self.perform_and_send_operation(2, "INSERT", 11, "!")
        self._deliver_operation(0, delayed_op)

        print("\nFinal Document States:")
        for i, process in enumerate(self.processes):
            print(f"Process {i}: '{process.document}'")
        print("\nEvent Log:")
        for i, event in enumerate(self.system_events):
            print(f"{i}: {event}")
        self.plot_process_timelines()

# Example usage
editor = CollaborativeEditorSystem(3, "Initial")
editor.run_simulation